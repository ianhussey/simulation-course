---
title: "Randomisation and the probability of observing balanced designs"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}

# set knit options
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE)

# disable scientific notation
options(scipen = 999) 

```

# Simulate

```{r}

# dependencies ----
# repeated here for the sake of completeness 

library(tidyr)
library(dplyr)
library(purrr) 
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(janitor)
library(forcats)


# set the seed ----
# for the pseudo random number generator to make results reproducible
set.seed(123)


# define data generating function ----
generate_data <- function(n, groups = 2) {
  res <- 
    tibble(group = sample(x = seq(from = 1, to = groups, by = 1), 
                          size = n, 
                          replace = TRUE)) |>
    count(group, name = "n_per_group") 
  
  return(res)
}


# define data analysis function ----
analyse_data <- function(data) {
  # check if all groups have the same number of participants
  all_groups_equal <- n_distinct(data$n_per_group) == 1
  
  # ratio
  min_n <- data |>
    filter(n_per_group == min(n_per_group)) |>
    pull(n_per_group)
  
  max_n <- data |>
    filter(n_per_group == max(n_per_group)) |>
    pull(n_per_group)
  
  ratio <- max_n / min_n
  
  # return results
  res <- tibble(
    all_groups_equal = all_groups_equal,
    max_n_diff = abs(max_n - min_n),
    all_groups_approx_equal = max_n_diff <= 1,
    ratio = ratio
  )
  
  return(res)
}


# define experiment parameters ----
experiment_parameters_grid <- expand_grid(
  n = seq(from = 10, to = 100, by = 10),
  groups = c(2, 3, 4),
  iteration = 1:10000
)

# run simulation ----
if(!file.exists("randomisation_and_balanced_designs.rds")){
  simulation <- 
    experiment_parameters_grid |>
    mutate(generated_data = pmap(list(n),
                                 generate_data)) |>
    mutate(analysis_results = pmap(list(generated_data),
                                   analyse_data)) |>
    unnest(analysis_results)
  
  write_rds(simulation, "randomisation_and_balanced_designs.rds")
} else {
  simulation <- read_rds("randomisation_and_balanced_designs.rds")
}

```

# Results

```{r fig.height=12, fig.width=5}

simulation |>
  mutate(n = paste0("n=",n),
         n = fct_relevel(n, "n=10","n=20","n=30","n=40","n=50","n=60","n=70","n=80","n=90","n=100"),
         groups = paste0("groups=",groups)) |>
  ggplot(aes(ratio)) +
  geom_histogram(boundary = 0) +
  #scale_x_continuous(breaks = scales::breaks_pretty(n = 10), limits = c(0,10)) +
  scale_x_log10(breaks = scales::breaks_pretty(n = 5)) +
  theme_linedraw() +
  facet_grid(n ~ groups)

```


```{r}

summary <- simulation |>
  group_by(groups, n) |>
  summarize(proportion_approx_balanced_n = mean(all_groups_approx_equal), 
            median_ratio = median(ratio), 
            .groups = "drop")

summary |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

ggplot(summary, aes(n, proportion_approx_balanced_n, color = as.factor(groups))) +
  geom_line() +
  geom_point() +
  coord_cartesian(ylim = c(0, NA)) + 
  scale_x_continuous(breaks = scales::breaks_pretty(n = 10)) +
  scale_y_continuous(labels = scales::label_percent()) +
  theme_linedraw() +
  xlab("Total N") +
  ylab("Approximately balanced") + 
  guides(color = guide_legend(title = "Groups"))

```


