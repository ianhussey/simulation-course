---
title: "Assessing the detectability of different causal models"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# TODO

- Think carefully about all decision making methods.
- Think carefully about simulated beta values, where they should be .5, 0 or otherwise.

# Data generation functions

## Item level data

```{r eval=FALSE, include=FALSE}

options(scipen=999)

# dependencies
library(tidyr)
library(dplyr)
library(purrr) 
library(lavaan)

# define data generating function ----

convert_alpha_to_lambda <- function(alpha, items) {
  lambda <- round( sqrt(alpha / (items - alpha * (items - 1))), digits = 5)
  return(lambda)
}

# convert_lambda_to_alpha <- function(lambda, items) {
#   alpha <- (items * lambda^2) / (1 + (items - 1) * lambda^2)
#   return(alpha)
# }

generate_lavaan_syntax_latent <- function(variable_name, cronbachs_alpha, items){
  if(cronbachs_alpha <= 0 || cronbachs_alpha >= 1){
    stop("Cronbach's alpha must be between 0 and 1 (exclusive).")
  }
  if(items <= 1){
    stop("Number of items must be greater than 1.")
  }
  
  model <- paste(variable_name, 
                 "_latent =~ " , 
                 paste(convert_alpha_to_lambda(alpha = cronbachs_alpha, items = items), 
                       "*", 
                       variable_name, 
                       "_", 
                       seq(1, items), 
                       sep = "", 
                       collapse = " + "), 
                 sep = "")
  
  return(model)
}

# generate_lavaan_syntax_latent(variable_name = "Y",
#                               cronbachs_alpha = .70,
#                               items = 10)

generate_model <- function(model,
                           cronbachs_alpha_y, 
                           cronbachs_alpha_m,
                           cronbachs_alpha_x, 
                           items_y,
                           items_m,
                           items_x){
  
  model_specification <- paste(
    generate_lavaan_syntax_latent(variable_name = "Y",
                                  cronbachs_alpha = cronbachs_alpha_y,
                                  items = items_y),
    generate_lavaan_syntax_latent(variable_name = "M",
                                  cronbachs_alpha = cronbachs_alpha_m,
                                  items = items_m),
    generate_lavaan_syntax_latent(variable_name = "X",
                                  cronbachs_alpha = cronbachs_alpha_x,
                                  items = items_x),
    model,
    sep = "; \n "
  ) |>
    str_remove_all(pattern = "  ")

  return(model_specification)
}

# generate_model(model = "Y_latent ~ 0.5*X_latent + 0.5*M_latent;
#                         X_latent ~~ 0.5*M_latent")

add_mean_scores <- function(data) {
  
  results <- data |>
    # select only the indicators' data
    dplyr::select(id, starts_with("Y"), starts_with("X"), starts_with("M")) |>
    dplyr::select(!contains("latent") & !contains("meanscore")) |>
    # make longer
    pivot_longer(cols = -id,
                 names_to = c("scale", "item"),
                 names_pattern = "(.)_(.)",
                 values_to = "score") |>
    # calculate means
    group_by(id, scale) |>
    dplyr::summarize(mean_score = mean(score), .groups = "keep") |>
    ungroup() |>
    # make wider again
    pivot_wider(id_cols = id,
                names_from = scale,
                #names_glue = "{scale}_mean",
                names_glue = "{scale}",
                values_from = mean_score) |>
    dplyr::select(-id) |>
    bind_cols(data)
  
  return(results)
}


generate_data <- function(n,
                          model,
                          cronbachs_alpha_y = .9,
                          cronbachs_alpha_m = .9,
                          cronbachs_alpha_x = .9,
                          items_y = 10,
                          items_m = 10,
                          items_x = 10) {
  
  data <- lavaan::simulateData(model = generate_model(model,
                                                      cronbachs_alpha_y = cronbachs_alpha_y,
                                                      cronbachs_alpha_m = cronbachs_alpha_m,
                                                      cronbachs_alpha_x = cronbachs_alpha_x,
                                                      items_y = items_y,
                                                      items_m = items_m,
                                                      items_x = items_x), sample.nobs = n,z) |>
    mutate(id = row_number()) |>
    add_mean_scores()
    
  return(data)
}

# temp <- generate_data(n = 100, 
#                       model = "Y_latent ~ 0.5*X_latent + 0.5*M_latent; X_latent ~~ 0.5*M_latent")


dat <- generate_data(n = 10000, 
                     model = "Y_latent ~ 0.5*X_latent + 0.5*M_latent; X_latent ~~ 0.5*M_latent",
                     cronbachs_alpha_y = .99,
                     cronbachs_alpha_m = .99,
                     cronbachs_alpha_x = .99)

lm(Y_mean ~ M_mean + X_mean,
   data = dat) |>
  summary()

```
## Scale level data

```{r}

# dependencies
library(tidyr)
library(dplyr)
library(purrr) 
library(lavaan)

# define data generating function ----

generate_data <- function(n,
                          model) {
  
  data <- lavaan::simulateData(model = model, sample.nobs = n) |>
    mutate(id = row_number())
    
  return(data)
}

```

# Plot causal models

Explain briefly why there's no fourth 3-variable model, ie because DAGs must be a-cyclic, they cant have causal loops, and the fourth model would have Y -> M -> X -> Y. 

```{r}

library(semPlot)

mod_bivariatecorrelation  <- "Y ~~ 0.5*X"
mod_simpleregression      <- "Y ~ 0.5*X"
mod_simpleregression_rev  <- "X ~ 0.5*Y"

mod_multipleregression    <- "Y ~ 0.5*X + 0.5*M; M ~~ 0.0*X"

mod_mediation             <- "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" # 0.71 * 0.71 = 0.5 indirect effect ?
mod_confounder            <- "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M"
mod_collider              <- "M ~ 0.5*X + 0.5*Y; Y ~ 0.0*X"
mod_network               <- "Y ~~ 0.5*X; Y ~~ 0.5*M; M ~~ 0.5*X"


# bivariate correlation
layout_matrix <- matrix(c( 1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_bivariatecorrelation, n = 300) %>%
  sem(model = mod_bivariatecorrelation, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Bivariate correlation", adj = 0)

# simple regression
layout_matrix <- matrix(c( 1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_simpleregression, n = 300) %>%
  sem(model = mod_simpleregression, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Simple regression", adj = 0)


# simple regression reversed causation
layout_matrix <- matrix(c(-1,  0,
                           1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_simpleregression_rev, n = 300) %>%
  sem(model = mod_simpleregression_rev, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Simple regression (opposite direction of causation)", adj = 0)


# network
layout_matrix <- matrix(c( 1,  0,
                           0,  1,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_network, n = 300) %>%
  sem(model = mod_network, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Network", adj = 0)


# multiple regression
layout_matrix <- matrix(c( 1,  0,
                          -1,  0,
                           0,  1), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_multipleregression, n = 300) %>%
  sem(model = mod_multipleregression, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Multiple regression", adj = 0)


# mediation
layout_matrix <- matrix(c( 1,  0,
                           0,  1,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_mediation, n = 300) %>%
  sem(model = mod_mediation, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Mediator", adj = 0)


# confounder
layout_matrix <- matrix(c( 1,  0,
                          -1,  0,
                           0,  1), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_confounder, n = 300) %>%
  sem(model = mod_confounder, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Confounder", adj = 0)


# collider 
layout_matrix <- matrix(c( 0,  1,
                           1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_collider, n = 300) %>%
  sem(model = mod_collider, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Collider", adj = 0)

```


```{r include=FALSE}

# save the same plots to disk
dir.create("plots")

# bivariate correlation
pdf(file = "plots/1_bivariate_correlation.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_bivariatecorrelation, n = 300) %>%
  sem(model = mod_bivariatecorrelation, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Bivariate correlation", adj = 0)

dev.off()

# simple regression
pdf(file = "plots/2_simple_regression.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_simpleregression, n = 300) %>%
  sem(model = mod_simpleregression, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Simple regression", adj = 0)

dev.off()

# simple regression reversed causation
pdf(file = "plots/3_simple_regression_reversed.pdf", width = 6, height = 5)

layout_matrix <- matrix(c(-1,  0,
                           1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_simpleregression_rev, n = 300) %>%
  sem(model = mod_simpleregression_rev, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Simple regression (opposite direction of causation)", adj = 0)

dev.off()

# network
pdf(file = "plots/4_network_of_correlations.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                           0,  1,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_network, n = 300) %>%
  sem(model = mod_network, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Network of correlations", adj = 0)

dev.off()


# multiple regression
pdf(file = "plots/5_multiple_regression.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                          -1,  0,
                           0,  1), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_multipleregression, n = 300) %>%
  sem(model = mod_multipleregression, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Multiple regression", adj = 0)

dev.off()

# mediation
pdf(file = "plots/6_mediation.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                           0,  1,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_mediation, n = 300) %>%
  sem(model = mod_mediation, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Mediator", adj = 0)

dev.off()

# confounder
pdf(file = "plots/7_confounder.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 1,  0,
                          -1,  0,
                           0,  1), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_confounder, n = 300) %>%
  sem(model = mod_confounder, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Confounder", adj = 0)

dev.off()

# collider 
pdf(file = "plots/8_collider.pdf", width = 6, height = 5)

layout_matrix <- matrix(c( 0,  1,
                           1,  0,
                          -1,  0), 
                        ncol = 2, 
                        byrow = TRUE)

generate_data(model = mod_collider, n = 300) %>%
  sem(model = mod_collider, data = .) |>
  semPaths(whatLabels = "diagram", 
           layout = layout_matrix, 
           residuals = FALSE,
           edge.label.cex = 1.2, 
           sizeMan = 10)
title(main = "Collider", adj = 0)

dev.off()

```

# Analysis functions

## All parameters

```{r eval=FALSE, include=FALSE}

analysis_simpleregression <- function(data){

  # specify model
  model <- '
           Y ~ X
           '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model_type = "regression",
           model = paste(lhs, rhs, sep = "_")) |>
    dplyr::select(model_type,
           model,
           pvalue,
           estimate = est,
           ci_lower = ci.lower,
           ci_upper = ci.upper) |>
    pivot_wider(names_from = model,
                values_from = c(pvalue, estimate, ci_lower, ci_upper),
                names_glue = "{model}_{.value}") |>
    mutate(decision_regression = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE))

  return(results)
}

analysis_multipleregression <- function(data){

  # specify model
  model <- '
           Y ~ X + M
           '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model_type = "multiple regression",
           model = paste(lhs, rhs, sep = "_")) |>
    dplyr::select(model_type,
           model,
           pvalue,
           estimate = est,
           ci_lower = ci.lower,
           ci_upper = ci.upper) |>
    pivot_wider(names_from = model,
                values_from = c(pvalue, estimate, ci_lower, ci_upper),
                names_glue = "{model}_{.value}") |>
    mutate(decision_multipleregression = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE))

  return(results)
}

analysis_mediation <- function(data){

  # specify model
  model <-  '
            M ~ a*X
            Y ~ b*M + c*X
            indirect := a*b
            direct := c
            total := c + (a*b)
            proportion_mediated := indirect / total
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op %in% c("~", ":=")) |>
    mutate(model_type = "mediation",
           model = paste(lhs, rhs, sep = "_"),
           model = case_when(
             model == "indirect_a*b" ~ "indirect",
             model == "direct_c" ~ "direct",
             model == "total_c+(a*b)" ~ "total",
             model == "proportion_mediated_indirect/total" ~ "proportion",
             TRUE ~ model
           )) |>
    dplyr::select(model_type,
           model,
           pvalue,
           estimate = est,
           ci_lower = ci.lower,
           ci_upper = ci.upper) |>
    pivot_wider(names_from = model,
                values_from = c(pvalue, estimate, ci_lower, ci_upper),
                names_glue = "{model}_{.value}") |>
    mutate(decision_mediation      = ifelse(indirect_pvalue < 0.05, TRUE, FALSE))
           #decision_2             = ifelse(direct_pvalue < 0.05, TRUE, FALSE), # not checked
           #decision_mediation_Y_X = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE),
           #decision_mediation_Y_M = ifelse(Y_M_pvalue < 0.05, TRUE, FALSE))

  return(results)
}

analysis_confounder <- function(data){

  # specify model
  model <-  '
            X ~ M
            Y ~ M + X
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model_type = "confounder",
           model = paste(lhs, rhs, sep = "_")) |>
    dplyr::select(model_type,
           model,
           pvalue,
           estimate = est,
           ci_lower = ci.lower,
           ci_upper = ci.upper) |>
    pivot_wider(names_from = model,
                values_from = c(pvalue, estimate, ci_lower, ci_upper),
                names_glue = "{model}_{.value}") |>
    # mutate(confounder =  ifelse(Y_X_pvalue < 0.05 &
    #                                Y_M_pvalue < 0.05 &
    #                                X_M_pvalue < 0.05, TRUE, FALSE))
    mutate(decision_confound =  ifelse(Y_M_pvalue < 0.05 &
                                         X_M_pvalue < 0.05, TRUE, FALSE))

  return(results)
}

analysis_collider <- function(data){

  # specify model
  model <-  '
            M ~ X + Y
            Y ~ X
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model_type = "collider",
           model = paste(lhs, rhs, sep = "_")) |>
    dplyr::select(model_type,
           model,
           pvalue,
           estimate = est,
           ci_lower = ci.lower,
           ci_upper = ci.upper) |>
    pivot_wider(names_from = model,
                values_from = c(pvalue, estimate, ci_lower, ci_upper),
                names_glue = "{model}_{.value}") |>
    # mutate(collider =  ifelse(Y_X_pvalue < 0.05 &
    #                             M_X_pvalue < 0.05 &
    #                             M_Y_pvalue < 0.05, TRUE, FALSE))
    mutate(decision_collider = ifelse(M_X_pvalue < 0.05 & M_Y_pvalue < 0.05, TRUE, FALSE))

  return(results)
}

analysis_correlations <- function(data){

  results_Y_X <-
    broom::tidy(cor.test(x = data$Y,
                         y = data$X,
                         alternative = "two.sided",
                         method = "pearson")) |>
    rename(Y_X_estimate = estimate,
           #Y_X_r        = estimate,
           Y_X_pvalue   = p.value,
           Y_X_ci_lower = conf.low,
           Y_X_ci_upper = conf.high) |>
    #mutate(decision_correlation_Y_X = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE)) |>
    mutate(decision_correlation = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE)) |>
    dplyr::select(Y_X_estimate,
           #Y_X_r,
           Y_X_pvalue,
           Y_X_ci_lower,
           Y_X_ci_upper,
           decision_correlation)

  results_Y_M <-
    broom::tidy(cor.test(x = data$Y,
                         y = data$M,
                         alternative = "two.sided",
                         method = "pearson")) |>
    rename(Y_M_estimate        = estimate,
           #Y_M_r        = estimate,
           Y_M_pvalue   = p.value,
           Y_M_ci_lower = conf.low,
           Y_M_ci_upper = conf.high) |>
    #mutate(decision_correlation_Y_M = ifelse(Y_M_pvalue < 0.05, TRUE, FALSE)) |>
    dplyr::select(Y_M_estimate,
           #Y_M_r,
           Y_M_pvalue,
           Y_M_ci_lower,
           Y_M_ci_upper)
           #decision_correlation_Y_M)

  results_M_X <-
    broom::tidy(cor.test(x = data$M,
                         y = data$X,
                         alternative = "two.sided",
                         method = "pearson")) |>
    rename(M_X_estimate = estimate,
           #M_X_r        = estimate,
           M_X_pvalue   = p.value,
           M_X_ci_lower = conf.low,
           M_X_ci_upper = conf.high) |>
    #mutate(decision_correlation_M_X = ifelse(M_X_pvalue < 0.05, TRUE, FALSE)) |>
    dplyr::select(M_X_estimate,
           #M_X_r,
           M_X_pvalue,
           M_X_ci_lower,
           M_X_ci_upper)
           #decision_correlation_M_X)

  results <-
    bind_cols(results_Y_X,
              results_Y_M,
              results_M_X) |>
    mutate(model_type = "correlations")

  return(results)
}

```

## p values and decisions only

```{r}

analysis_bivariatecorrelation <- function(data){
  
  results <- 
    broom::tidy(cor.test(x = data$Y,
                         y = data$X,
                         alternative = "two.sided",
                         method = "pearson")) |>
    mutate(effect = "Y_X") |>
    mutate(analysis_fitted = "bivariate correlation (Y ~~ X)") |>
    dplyr::select(analysis_fitted,
                  effect,
                  estimate, 
                  pvalue = p.value)
  
  return(results)
}

analysis_simpleregression <- function(data){
  
  # specify model
  model <- '
           Y ~ X
           '
  
  # fit model
  fit <- sem(model = model, data = data)
  
  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model = paste(lhs, rhs, sep = "_")) |>
    mutate(effect = "Y_X") |>
    mutate(analysis_fitted = "simple regression (Y ~ X)") |>
    dplyr::select(analysis_fitted,
                  effect,
                  estimate = est,
                  pvalue = pvalue)

  return(results)
}

analysis_simpleregressionrev <- function(data){
  
  # specify model
  model <- '
           X ~ Y
           '
  
   # fit model
  fit <- sem(model = model, data = data)
  
  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model = paste(lhs, rhs, sep = "_")) |>
    mutate(effect = "Y_X") |>
    mutate(analysis_fitted = "simple regression (Y ~ X)") |>
    dplyr::select(analysis_fitted,
                  effect,
                  estimate = est,
                  pvalue = pvalue)
  
  return(results)
}



analysis_multipleregression <- function(data){

  # specify model
  model <- '
           Y ~ X + M
           '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(model = paste(lhs, rhs, sep = "_")) |>
    mutate(analysis_fitted = "multipleregression (Y ~ X + M)") |>
    dplyr::select(analysis_fitted,
                  effect = model,
                  pvalue,
                  estimate = est) 

  return(results)
}

analysis_mediation <- function(data){

  # specify model
  model <-  '
            M ~ a*X
            Y ~ b*M + c*X
            indirect := a*b
            direct := c
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op %in% c("~", ":=")) |>
    mutate(analysis_fitted = "mediation (Y ~ X + M; M ~ X)",
           effect = paste(lhs, rhs, sep = "_"),
           effect = case_when(
             effect == "indirect_a*b" ~ "indirect",
             effect == "direct_c" ~ "direct",
             TRUE ~ effect
           )) |>
    dplyr::select(analysis_fitted,
                  effect,
                  estimate = est,
                  pvalue)

  return(results)
}

analysis_confounder <- function(data){

  # specify model
  model <-  '
            X ~ M
            Y ~ X + M
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(effect = paste(lhs, rhs, sep = "_")) |>
    mutate(analysis_fitted = "confounder (Y ~ X + M)") |>
    dplyr::select(analysis_fitted,
                  effect,
                  pvalue,
                  estimate = est) 

  return(results)
}

analysis_collider <- function(data){

  # specify model
  model <-  '
            M ~ X + Y
            Y ~ X
            '

  # fit model
  fit <- sem(model = model, data = data)

  # extract results
  results <- parameterEstimates(fit) |>
    dplyr::filter(op == "~") |>
    mutate(effect = paste(lhs, rhs, sep = "_")) |>
    mutate(analysis_fitted = "collider (M ~ X + Y)") |>
    dplyr::select(analysis_fitted,
                  effect,
                  pvalue,
                  estimate = est) 

  return(results)
}

# 
# analysis_correlations <- function(data){
#   
#   results_Y_X <- 
#     broom::tidy(cor.test(x = data$Y,
#                          y = data$X,
#                          alternative = "two.sided",
#                          method = "pearson")) |>
#     rename(Y_X_estimate = estimate,
#            #Y_X_r        = estimate,
#            Y_X_pvalue   = p.value,
#            Y_X_ci_lower = conf.low,
#            Y_X_ci_upper = conf.high) |>
#     #mutate(decision_correlation_Y_X = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE)) |>
#     mutate(decision_correlation = ifelse(Y_X_pvalue < 0.05, TRUE, FALSE)) |>
#     dplyr::select(Y_X_estimate,
#            #Y_X_r,
#            Y_X_pvalue,
#            Y_X_ci_lower,
#            Y_X_ci_upper,
#            decision_correlation)
#   
#   results_Y_M <- 
#     broom::tidy(cor.test(x = data$Y,
#                          y = data$M,
#                          alternative = "two.sided",
#                          method = "pearson")) |>
#     rename(Y_M_estimate        = estimate,
#            #Y_M_r        = estimate,
#            Y_M_pvalue   = p.value,
#            Y_M_ci_lower = conf.low,
#            Y_M_ci_upper = conf.high) |>
#     #mutate(decision_correlation_Y_M = ifelse(Y_M_pvalue < 0.05, TRUE, FALSE)) |>
#     dplyr::select(Y_M_estimate,
#            #Y_M_r,
#            Y_M_pvalue,
#            Y_M_ci_lower,
#            Y_M_ci_upper)
#            #decision_correlation_Y_M)
#   
#   results_M_X <- 
#     broom::tidy(cor.test(x = data$M,
#                          y = data$X,
#                          alternative = "two.sided",
#                          method = "pearson")) |>
#     rename(M_X_estimate = estimate,
#            #M_X_r        = estimate,
#            M_X_pvalue   = p.value,
#            M_X_ci_lower = conf.low,
#            M_X_ci_upper = conf.high) |>
#     #mutate(decision_correlation_M_X = ifelse(M_X_pvalue < 0.05, TRUE, FALSE)) |>
#     dplyr::select(M_X_estimate,
#            #M_X_r,
#            M_X_pvalue,
#            M_X_ci_lower,
#            M_X_ci_upper)
#            #decision_correlation_M_X)
#   
#   results <- 
#     bind_cols(results_Y_X, 
#               results_Y_M,
#               results_M_X) |>
#     mutate(model_type = "network")
#   
#   return(results)
# }

```

# Run simulations

## all models for dev

```{r}

# define experiment parameters ----

mod_bivariatecorrelation  <- "Y ~~ 0.5*X"
mod_simpleregression      <- "Y ~ 0.5*X"
mod_simpleregression_rev  <- "X ~ 0.5*Y"

mod_multipleregression    <- "Y ~ 0.5*X + 0.5*M; M ~~ 0.0*X"

mod_mediation             <- "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" # 0.71 * 0.71 = 0.5 indirect effect ?
mod_confounder            <- "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M"
mod_collider              <- "M ~ 0.5*X + 0.5*Y; Y ~~ 0.0*X"
mod_network               <- "Y ~~ 0.5*X; Y ~~ 0.5*M; M ~~ 0.5*X"

# additional
mod_mediation_withdirect  <- "Y ~ 0.5*M + 0.5*X; M ~ 0.5*X" # 0.71 * 0.71 = 0.5 indirect effect ?
mod_confounder_withdirect <- "Y ~ 0.5*X + 0.5*M; X ~ 0.5*M"
mod_collider_withdirect   <- "M ~ 0.5*X + 0.5*Y; Y ~ 0.5*X"

```

- \TODO: compare the with-direct models to the ones without this. 


```{r}

# run simulation ----

# simulation <- 
#   # using the experiment parameters
#   experiment_parameters_grid |>
#   
#   # generate data using the data generating function and the parameters relevant to data generation
#   mutate(data = pmap(list(n,
#                           population_model),
#                      generate_data)) |>
#   
#   # apply the analysis function to the generated data using the parameters relevant to analysis
#   mutate(
#     # agnostic to causality
#     results_correlations       = pmap(list(data),
#                                       analysis_correlations),
#     # agnostic to M ~~ X causality
#     results_multipleregression = pmap(list(data),
#                                       analysis_multipleregression),
#     # specified causality
#     results_mediation          = pmap(list(data),
#                                       analysis_mediation),
#     results_confounder         = pmap(list(data),
#                                       analysis_confounder),
#     results_collider           = pmap(list(data),
#                                       analysis_collider)
#   ) 


# summarise simulation results over the iterations ----

# simulation_summary <- simulation |>
#   unnest(results_multipleregression) |>
#   dplyr::select(n, population_model_description, population_model, iteration, data, starts_with("results"), starts_with("decision_")) |>
#   unnest(results_mediation) |>
#   dplyr::select(n, population_model_description, population_model, iteration, data, starts_with("results"), starts_with("decision_")) |>
#   rename(decision_mediation = decision_mediation_indirect) |>
#   dplyr::select(-decision_mediation_baronkenny) |>
#   unnest(results_confounder) |>
#   dplyr::select(n, population_model_description, population_model, iteration, data, starts_with("results"), starts_with("decision_")) |>
#   unnest(results_collider) |>
#   dplyr::select(n, population_model_description, population_model, iteration, data, starts_with("results"), starts_with("decision_")) |>
#   unnest(results_correlations) |>
#   dplyr::select(n, population_model_description, population_model, iteration, data, starts_with("results"), starts_with("decision_")) |>
#   pivot_longer(cols = starts_with("decision_"),
#                names_to = "analysis",
#                values_to = "result") |>
#   mutate(analysis = str_remove(analysis, "decision_")) |>
#   group_by(population_model_description, analysis) |>
#   summarize(proportion_significant = mean(result), .groups = "drop")

```

## Are regressions robust to the assumption of causality?

```{r}

mod_bivariatecorrelation  <- "Y ~~ 0.5*X"
mod_simpleregression      <- "Y ~ 0.5*X"
mod_simpleregression_rev  <- "X ~ 0.5*Y"

experiment_parameters_grid <- expand_grid(
  n = 100,
  population_model = c(mod_bivariatecorrelation,
                       mod_simpleregression,
                       mod_simpleregression_rev),
  iteration = 1:10
) |>
  mutate(population_model_description = 
           case_when(population_model == mod_bivariatecorrelation ~ "bivariate correlation (Y ~~ X)",
                     population_model == mod_simpleregression ~ "simple regression (Y ~ X)",
                     population_model == mod_simpleregression_rev ~ "simple regression (X ~ Y)",
                     TRUE ~ population_model)
  )

simulation <- 
  # using the experiment parameters
  experiment_parameters_grid |>
  
  # generate data using the data generating function and the parameters relevant to data generation
  mutate(data = pmap(list(n,
                          population_model),
                     generate_data)) |>
  
  # apply the analysis function to the generated data using the parameters relevant to analysis
  mutate(
    results_bivariatecorrelation = pmap(list(data),
                                        analysis_bivariatecorrelation),
    results_simpleregression     = pmap(list(data),
                                        analysis_simpleregression),
    results_simpleregressionrev  = pmap(list(data),
                                        analysis_simpleregressionrev)
  ) 


simulation_reshaped <- 
  bind_rows(
    simulation |>
      unnest(results_bivariatecorrelation) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue),
    simulation |>
      unnest(results_simpleregression) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue),
    simulation |>
      unnest(results_simpleregressionrev) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue)
  )
  
simulation_summary <- simulation_reshaped |>  
  filter(effect == "Y_X") |>
  group_by(population_model_description, analysis_fitted) |>
  summarize(proportion_positive_decision = mean(pvalue < .05), 
            mean_YX_estimate = mean(estimate),
            .groups = "drop")

#write_csv(simulation_summary, "causal_models_simulation_summary_xy.csv")

simulation_summary |>
  mutate(correctly_specified = population_model_description == analysis_fitted) |>
  relocate(correctly_specified, .after = analysis_fitted) |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

#   ggplot(aes(population_model_description, fill = analysis)) +
#   geom_bar(position = position_dodge(width = .95)) +
#   labs(y = "Proportion with significant results",
#        x = "Population model") +
#   theme_linedraw() +
#   scale_fill_viridis_d(begin = 0.2, end = 0.7)

```

## What happens when we add a third variable?

- we're usually agnostic to the relationships between the X and M variables. does it matter? manipulate a non causal correlation. 
- what about when its causal? show that the wrong model often fits the data well, ie produces false positive results that otherwise look right. relate this back to causal langage papers, relate to haller and gloster paper; relate to the exercise and cognition papers.

\TODO the above


## Demonstration of collider bias

putting aside the p values, what about the estimates? colliders are particularly scary as they produce spurious correlations. 

give lots of clear real world examples of colliders to convey this point.

\TODO get the spurious correlation working

```{r}

mod_collider <- "M ~ 0.5*X + 0.5*Y; Y ~~ 0.0*X"

experiment_parameters_grid <- expand_grid(
  n = 100,
  population_model = mod_collider,
  iteration = 1:1000
) |>
  mutate(population_model_description = case_when(population_model == mod_collider ~ "collider (M ~ X + Y)",
                                                  TRUE ~ population_model))

simulation <- 
  experiment_parameters_grid |>
  mutate(data                       = pmap(list(n, population_model), generate_data)) |>
  mutate(results_multipleregression = pmap(list(data), analysis_multipleregression)) 


simulation_reshaped <- simulation |>
  unnest(results_multipleregression) |>
  dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue)
  
simulation_summary <- simulation_reshaped |>  
  filter(effect == "Y_X") |>
  group_by(population_model_description, analysis_fitted) |>
  summarize(proportion_positive_decision = mean(pvalue < .05), 
            mean_YX_estimate = mean(estimate),
            .groups = "drop")

#write_csv(simulation_summary, "causal_models_simulation_summary_xy.csv")

simulation_summary |>
  mutate(correctly_specified = population_model_description == analysis_fitted) |>
  relocate(correctly_specified, .after = analysis_fitted) |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

#   ggplot(aes(population_model_description, fill = analysis)) +
#   geom_bar(position = position_dodge(width = .95)) +
#   labs(y = "Proportion with significant results",
#        x = "Population model") +
#   theme_linedraw() +
#   scale_fill_viridis_d(begin = 0.2, end = 0.7)

```

## Contrasting population and analysis

- mediation: depression can cause feelings of entrapment, and entrapment can then cause suicidal ideation.
- confounder: feelings of entrapment can cause depression, and both depression and entrapment can cause suicidal ideation.
- collider: depression and suicidal ideation can both cause feelings of entrapment.

```{r}

# mod_mediation  <- "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" 
# mod_confounder <- "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M"
# mod_collider   <- "M ~ 0.5*X + 0.5*Y; Y ~~ 0.0*X"

# mod_mediation  <- "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" 
# mod_confounder <- "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M"
# mod_collider   <- "M ~ 0.5*X + 0.5*Y; Y ~ 0.0*X" # make this causal but still zero

mod_mediation_small   <- "Y ~ 0.1*M + 0.0*X; M ~ 0.1*X" 
mod_confounder_small  <- "Y ~ 0.0*X + 0.1*M; X ~ 0.1*M"
mod_collider_small    <- "M ~ 0.1*X + 0.1*Y; Y ~ 0.0*X" # make this causal but still zero
mod_mediation_medium  <- "Y ~ 0.3*M + 0.0*X; M ~ 0.3*X" 
mod_confounder_medium <- "Y ~ 0.0*X + 0.3*M; X ~ 0.3*M"
mod_collider_medium   <- "M ~ 0.3*X + 0.3*Y; Y ~ 0.0*X" # make this causal but still zero
mod_mediation_large   <- "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" 
mod_confounder_large  <- "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M"
mod_collider_large    <- "M ~ 0.5*X + 0.5*Y; Y ~ 0.0*X" # make this causal but still zero
mod_mediation_verylarge   <- "Y ~ 0.8*M + 0.0*X; M ~ 0.8*X" 
mod_confounder_verylarge  <- "Y ~ 0.0*X + 0.8*M; X ~ 0.8*M"
mod_collider_verylarge    <- "M ~ 0.8*X + 0.8*Y; Y ~ 0.0*X" # make this causal but still zero

experiment_parameters_grid <- expand_grid(
  n = 100,
  population_model = c(mod_mediation_small,
                       mod_confounder_small,
                       mod_collider_small,
                       mod_mediation_medium,
                       mod_confounder_medium,
                       mod_collider_medium,
                       mod_mediation_large,
                       mod_confounder_large,
                       mod_collider_large,
                       mod_mediation_verylarge,
                       mod_confounder_verylarge,
                       mod_collider_verylarge),
  iteration = 1:1000
) |>
  mutate(population_model_description = case_when(population_model == "Y ~ 0.1*M + 0.0*X; M ~ 0.1*X" ~ "mediation",
                                                  population_model == "Y ~ 0.3*M + 0.0*X; M ~ 0.3*X" ~ "mediation",
                                                  population_model == "Y ~ 0.5*M + 0.0*X; M ~ 0.5*X" ~ "mediation",
                                                  population_model == "Y ~ 0.8*M + 0.0*X; M ~ 0.8*X" ~ "mediation",
                                                  population_model == "Y ~ 0.0*X + 0.1*M; X ~ 0.1*M" ~ "confounder",
                                                  population_model == "Y ~ 0.0*X + 0.3*M; X ~ 0.3*M" ~ "confounder",
                                                  population_model == "Y ~ 0.0*X + 0.5*M; X ~ 0.5*M" ~ "confounder",
                                                  population_model == "Y ~ 0.0*X + 0.8*M; X ~ 0.8*M" ~ "confounder",
                                                  population_model == "M ~ 0.1*X + 0.1*Y; Y ~ 0.0*X" ~ "collider",
                                                  population_model == "M ~ 0.3*X + 0.3*Y; Y ~ 0.0*X" ~ "collider",
                                                  population_model == "M ~ 0.5*X + 0.5*Y; Y ~ 0.0*X" ~ "collider",
                                                  population_model == "M ~ 0.8*X + 0.8*Y; Y ~ 0.0*X" ~ "collider",
                                                  TRUE ~ population_model),
         population_YX_effect = 0,
         population_M_effect = case_when(str_detect(population_model, "0.1") ~ "0.1",
                                         str_detect(population_model, "0.3") ~ "0.3",
                                         str_detect(population_model, "0.5") ~ "0.5",
                                         str_detect(population_model, "0.8") ~ "0.8",
                                         TRUE ~ population_model),
         population_M_effect = as.numeric(as.character(population_M_effect)))

```

### One analysis

This one is interesting and more accessible as in all three cases the population direct Y~X effect is 0, and the data is analyzed the same way, but the observed Y~X relationship differs based on the causal relationships elsewhere.

The researcher is always to estimate the causal impact of X (depression) on Y (suicidal ideation). Because they don't have strong causal inference skills, they are trying "to control for the influence of M (entrapment)", because they've learned that controlling for covariates is good. But what role does this covariate play in the true causal model? And how might this affect the results? 

```{r}

# simulation <- 
#   experiment_parameters_grid |>
#   mutate(data                       = pmap(list(n, population_model), generate_data)) |>
#   mutate(results_multipleregression = pmap(list(data), analysis_multipleregression))
# 
# simulation_summary <- simulation |>
#   unnest(results_multipleregression) |>
#   dplyr::select(n, population_model_description, population_model, 
#                 population_YX_effect, population_M_effect, 
#                 iteration, analysis_fitted, effect, estimate, pvalue) |>  
#   filter(effect == "Y_X") |>
#   group_by(population_model_description, population_YX_effect, population_M_effect) |>
#   summarize(proportion_positive_decision = mean(pvalue < .05), 
#             mean_YX_estimate = mean(estimate),
#             .groups = "drop")
# 
# write_csv(simulation_summary, "causal_models_multiple_causal_models_one_analysis.csv")
simulation_summary <- read_csv("causal_models_multiple_causal_models_one_analysis.csv")

simulation_summary |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

ggplot(simulation_summary, aes(population_model_description, mean_YX_estimate, fill = as.factor(population_M_effect))) +
  #geom_hline(yintercept = 0, linetype = "solid") +
  geom_col(position = position_dodge(width = .9), color = "black") +
  scale_fill_manual(values = c("#00AFBB", "#E7B800", "#FC4E07", "#52854C"),
                    name = "Population effects\ninvoving M") +
  labs(y = "Mean estimated effect\nof X on Y",
       x = "Role of M\nin population causal model",
       title = "Multiple regression analysis (Y ~ X + M)",
       subtitle = "Population effect of X on Y is always 0") +
  theme_linedraw()

ggsave("plots/causal_models_multiple_causal_models_one_analysis.pdf",
       width = 6,
       height = 4)

```

### Many analyses

```{r}

simulation <- 
  experiment_parameters_grid |>
  mutate(data                       = pmap(list(n, population_model), generate_data)) |>
  mutate(results_multipleregression = pmap(list(data), analysis_multipleregression),
         results_mediation          = pmap(list(data), analysis_mediation),
         results_confounder         = pmap(list(data), analysis_confounder),
         results_collider           = pmap(list(data), analysis_collider))

simulation_reshaped <- 
  bind_rows(
    simulation |>
      unnest(results_multipleregression) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue),
    simulation |>
      unnest(results_mediation) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue),
    simulation |>
      unnest(results_confounder) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue),
    simulation |>
      unnest(results_collider) |>
      dplyr::select(n, population_model_description, population_model, iteration, analysis_fitted, effect, estimate, pvalue)
  )
  
simulation_summary <- simulation_reshaped |>  
  filter(effect == "Y_X") |>
  group_by(population_model_description, analysis_fitted) |>
  summarize(proportion_positive_decision = mean(pvalue < .05), 
            mean_YX_estimate = mean(estimate),
            .groups = "drop")

#write_csv(simulation_summary, "causal_models_simulation_summary_xy.csv")

simulation_summary |>
  mutate(correctly_specified = population_model_description == analysis_fitted) |>
  relocate(correctly_specified, .after = analysis_fitted) |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

#   ggplot(aes(population_model_description, fill = analysis)) +
#   geom_bar(position = position_dodge(width = .95)) +
#   labs(y = "Proportion with significant results",
#        x = "Population model") +
#   theme_linedraw() +
#   scale_fill_viridis_d(begin = 0.2, end = 0.7)

```

- estimates where the population and the analysis have opposing causality will demonstrate reduced estimates. note that this cannot be used to deduce the true direction of causality for several reasons we won't get into here.

# Session info

```{r}

sessionInfo()

```


